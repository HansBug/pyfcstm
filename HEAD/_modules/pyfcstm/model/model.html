

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyfcstm.model.model &mdash; pyfcstm 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css?v=c9d0a6ec" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            pyfcstm
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/installation/index.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/quick_start/index.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/dsl/index.html">PyFCSTM DSL Syntax Tutorial</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../information/environment.result.html">Run Environment Information</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api_doc/config/index.html">pyfcstm.config</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_doc/dsl/index.html">pyfcstm.dsl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_doc/entry/index.html">pyfcstm.entry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_doc/model/index.html">pyfcstm.model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_doc/render/index.html">pyfcstm.render</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_doc/utils/index.html">pyfcstm.utils</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">pyfcstm</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pyfcstm.model.model</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
    
    
  <h1>Source code for pyfcstm.model.model</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">State machine module for parsing and representing hierarchical state machines.</span>

<span class="sd">This module provides classes and functions for working with state machines, including:</span>

<span class="sd">- Representation of states, transitions, events, and operations</span>
<span class="sd">- Parsing state machine DSL nodes into state machine objects</span>
<span class="sd">- Exporting state machines to AST nodes and PlantUML diagrams</span>

<span class="sd">The module implements a hierarchical state machine model with support for:</span>

<span class="sd">- Nested states</span>
<span class="sd">- Entry, during, and exit actions</span>
<span class="sd">- Guards and effects on transitions</span>
<span class="sd">- Abstract function declarations</span>
<span class="sd">- Variable definitions</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">io</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">weakref</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">textwrap</span><span class="w"> </span><span class="kn">import</span> <span class="n">indent</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.base</span><span class="w"> </span><span class="kn">import</span> <span class="n">AstExportable</span><span class="p">,</span> <span class="n">PlantUMLExportable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.expr</span><span class="w"> </span><span class="kn">import</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">parse_expr_node_to_expr</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..dsl</span><span class="w"> </span><span class="kn">import</span> <span class="n">node</span> <span class="k">as</span> <span class="n">dsl_nodes</span><span class="p">,</span> <span class="n">INIT_STATE</span><span class="p">,</span> <span class="n">EXIT_STATE</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;Operation&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Event&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Transition&#39;</span><span class="p">,</span>
    <span class="s1">&#39;OnStage&#39;</span><span class="p">,</span>
    <span class="s1">&#39;OnAspect&#39;</span><span class="p">,</span>
    <span class="s1">&#39;State&#39;</span><span class="p">,</span>
    <span class="s1">&#39;VarDefine&#39;</span><span class="p">,</span>
    <span class="s1">&#39;StateMachine&#39;</span><span class="p">,</span>
    <span class="s1">&#39;parse_dsl_node_to_state_machine&#39;</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="Operation">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.Operation">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Operation</span><span class="p">(</span><span class="n">AstExportable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents an operation that assigns a value to a variable.</span>

<span class="sd">    An operation consists of a variable name and an expression that will be</span>
<span class="sd">    assigned to the variable when the operation is executed.</span>

<span class="sd">    :param var_name: The name of the variable to assign to</span>
<span class="sd">    :type var_name: str</span>
<span class="sd">    :param expr: The expression to evaluate and assign to the variable</span>
<span class="sd">    :type expr: Expr</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">var_name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span>

<div class="viewcode-block" id="Operation.to_ast_node">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.Operation.to_ast_node">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_ast_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">OperationAssignment</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert this operation to an AST node.</span>

<span class="sd">        :return: An operation assignment AST node</span>
<span class="sd">        :rtype: dsl_nodes.OperationAssignment</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">OperationAssignment</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">,</span>
            <span class="n">expr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">(),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Operation.var_name_to_ast_node">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.Operation.var_name_to_ast_node">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">var_name_to_ast_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">Name</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the variable name to an AST node.</span>

<span class="sd">        :return: A name AST node</span>
<span class="sd">        :rtype: dsl_nodes.Name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">Name</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="Event">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.Event">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Event</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents an event that can trigger state transitions.</span>

<span class="sd">    An event has a name and is associated with a specific state path in the</span>
<span class="sd">    state machine hierarchy.</span>

<span class="sd">    :param name: The name of the event</span>
<span class="sd">    :type name: str</span>
<span class="sd">    :param state_path: The path to the state that owns this event</span>
<span class="sd">    :type state_path: Tuple[str, ...]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">state_path</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">path</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the full path of the event including the state path and event name.</span>

<span class="sd">        :return: The full path to the event</span>
<span class="sd">        :rtype: Tuple[str, ...]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">((</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">state_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span></div>



<div class="viewcode-block" id="Transition">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.Transition">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Transition</span><span class="p">(</span><span class="n">AstExportable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a transition between states in a state machine.</span>

<span class="sd">    A transition defines how the state machine moves from one state to another,</span>
<span class="sd">    potentially triggered by an event, guarded by a condition, and with effects</span>
<span class="sd">    that execute when the transition occurs.</span>

<span class="sd">    :param from_state: The source state name or special state marker</span>
<span class="sd">    :type from_state: Union[str, dsl_nodes._StateSingletonMark]</span>
<span class="sd">    :param to_state: The target state name or special state marker</span>
<span class="sd">    :type to_state: Union[str, dsl_nodes._StateSingletonMark]</span>
<span class="sd">    :param event: The event that triggers this transition, if any</span>
<span class="sd">    :type event: Optional[Event]</span>
<span class="sd">    :param guard: The condition that must be true for the transition to occur, if any</span>
<span class="sd">    :type guard: Optional[Expr]</span>
<span class="sd">    :param effects: Operations to execute when the transition occurs</span>
<span class="sd">    :type effects: List[Operation]</span>
<span class="sd">    :param parent_ref: Weak reference to the parent state</span>
<span class="sd">    :type parent_ref: Optional[weakref.ReferenceType]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">from_state</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">_StateSingletonMark</span><span class="p">]</span>
    <span class="n">to_state</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">_StateSingletonMark</span><span class="p">]</span>
    <span class="n">event</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Event</span><span class="p">]</span>
    <span class="n">guard</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Expr</span><span class="p">]</span>
    <span class="n">effects</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Operation</span><span class="p">]</span>
    <span class="n">parent_ref</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">weakref</span><span class="o">.</span><span class="n">ReferenceType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;State&#39;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the parent state of this transition.</span>

<span class="sd">        :return: The parent state or None if no parent is set</span>
<span class="sd">        :rtype: Optional[&#39;State&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_ref</span><span class="p">()</span>

    <span class="nd">@parent</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;State&#39;</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the parent state of this transition.</span>

<span class="sd">        :param new_parent: The new parent state or None to clear the parent</span>
<span class="sd">        :type new_parent: Optional[&#39;State&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent_ref</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent_ref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">new_parent</span><span class="p">)</span>

<div class="viewcode-block" id="Transition.to_ast_node">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.Transition.to_ast_node">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_ast_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">ASTNode</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert this transition to an AST node.</span>

<span class="sd">        :return: A transition definition AST node</span>
<span class="sd">        :rtype: dsl_nodes.ASTNode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">State</span><span class="o">.</span><span class="n">transition_to_ast_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="OnStage">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.OnStage">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">OnStage</span><span class="p">(</span><span class="n">AstExportable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents an action that occurs during a specific stage of a state&#39;s lifecycle.</span>

<span class="sd">    OnStage can represent enter, during, or exit actions, and can be either concrete</span>
<span class="sd">    operations or abstract function declarations.</span>

<span class="sd">    :param stage: The lifecycle stage (&#39;enter&#39;, &#39;during&#39;, or &#39;exit&#39;)</span>
<span class="sd">    :type stage: str</span>
<span class="sd">    :param aspect: For &#39;during&#39; actions in composite states, specifies if the action occurs &#39;before&#39; or &#39;after&#39; substates</span>
<span class="sd">    :type aspect: Optional[str]</span>
<span class="sd">    :param name: For abstract functions, the name of the function</span>
<span class="sd">    :type name: Optional[str]</span>
<span class="sd">    :param doc: For abstract functions, the documentation string</span>
<span class="sd">    :type doc: Optional[str]</span>
<span class="sd">    :param operations: For concrete actions, the list of operations to execute</span>
<span class="sd">    :type operations: List[Operation]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stage</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">aspect</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">doc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">operations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Operation</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_abstract</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if this is an abstract function declaration.</span>

<span class="sd">        :return: True if this is an abstract function, False otherwise</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_aspect</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if this is an aspect-oriented action.</span>

<span class="sd">        :return: False for OnStage instances (always)</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="OnStage.to_ast_node">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.OnStage.to_ast_node">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_ast_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">dsl_nodes</span><span class="o">.</span><span class="n">EnterStatement</span><span class="p">,</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">DuringStatement</span><span class="p">,</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">ExitStatement</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert this OnStage to an appropriate AST node based on the stage.</span>

<span class="sd">        :return: An enter, during, or exit statement AST node</span>
<span class="sd">        :rtype: Union[dsl_nodes.EnterStatement, dsl_nodes.DuringStatement, dsl_nodes.ExitStatement]</span>
<span class="sd">        :raises ValueError: If the stage is not one of &#39;enter&#39;, &#39;during&#39;, or &#39;exit&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stage</span> <span class="o">==</span> <span class="s1">&#39;enter&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">EnterAbstractFunction</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">EnterOperations</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">operations</span><span class="o">=</span><span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operations</span><span class="p">],</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">stage</span> <span class="o">==</span> <span class="s1">&#39;during&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">DuringAbstractFunction</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">aspect</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">aspect</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">DuringOperations</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">aspect</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">aspect</span><span class="p">,</span>
                    <span class="n">operations</span><span class="o">=</span><span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operations</span><span class="p">],</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">stage</span> <span class="o">==</span> <span class="s1">&#39;exit&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">ExitAbstractFunction</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">ExitOperations</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">operations</span><span class="o">=</span><span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operations</span><span class="p">],</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown stage - </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stage</span><span class="si">!r}</span><span class="s1">.&#39;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span></div>
</div>



<div class="viewcode-block" id="OnAspect">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.OnAspect">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">OnAspect</span><span class="p">(</span><span class="n">AstExportable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents an aspect-oriented action that occurs during a specific stage of a state&#39;s lifecycle.</span>

<span class="sd">    OnAspect is specifically used for aspect-oriented programming features in the state machine,</span>
<span class="sd">    allowing actions to be defined that apply across multiple states.</span>

<span class="sd">    :param stage: The lifecycle stage (currently only supports &#39;during&#39;)</span>
<span class="sd">    :type stage: str</span>
<span class="sd">    :param aspect: Specifies if the action occurs &#39;before&#39; or &#39;after&#39; substates</span>
<span class="sd">    :type aspect: Optional[str]</span>
<span class="sd">    :param name: For abstract functions, the name of the function</span>
<span class="sd">    :type name: Optional[str]</span>
<span class="sd">    :param doc: For abstract functions, the documentation string</span>
<span class="sd">    :type doc: Optional[str]</span>
<span class="sd">    :param operations: For concrete actions, the list of operations to execute</span>
<span class="sd">    :type operations: List[Operation]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stage</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">aspect</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">doc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">operations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Operation</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_abstract</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if this is an abstract function declaration.</span>

<span class="sd">        :return: True if this is an abstract function, False otherwise</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_aspect</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if this is an aspect-oriented action.</span>

<span class="sd">        :return: True for OnAspect instances (always)</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="OnAspect.to_ast_node">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.OnAspect.to_ast_node">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_ast_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">dsl_nodes</span><span class="o">.</span><span class="n">DuringAspectStatement</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert this OnAspect to an appropriate AST node based on the stage.</span>

<span class="sd">        :return: A during aspect statement AST node</span>
<span class="sd">        :rtype: Union[dsl_nodes.DuringAspectStatement]</span>
<span class="sd">        :raises ValueError: If the stage is not &#39;during&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stage</span> <span class="o">==</span> <span class="s1">&#39;during&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">DuringAspectAbstractFunction</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">aspect</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">aspect</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">DuringAspectOperations</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">aspect</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">aspect</span><span class="p">,</span>
                    <span class="n">operations</span><span class="o">=</span><span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operations</span><span class="p">],</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown aspect - </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stage</span><span class="si">!r}</span><span class="s1">.&#39;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span></div>
</div>



<div class="viewcode-block" id="State">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.State">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">State</span><span class="p">(</span><span class="n">AstExportable</span><span class="p">,</span> <span class="n">PlantUMLExportable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a state in a hierarchical state machine.</span>

<span class="sd">    A state can contain substates, transitions between those substates, and actions</span>
<span class="sd">    that execute on enter, during, or exit of the state.</span>

<span class="sd">    :param name: The name of the state</span>
<span class="sd">    :type name: str</span>
<span class="sd">    :param path: The full path to this state in the hierarchy</span>
<span class="sd">    :type path: Tuple[str, ...]</span>
<span class="sd">    :param substates: Dictionary mapping substate names to State objects</span>
<span class="sd">    :type substates: Dict[str, &#39;State&#39;]</span>
<span class="sd">    :param events: Dictionary mapping event names to Event objects</span>
<span class="sd">    :type events: Dict[str, Event]</span>
<span class="sd">    :param transitions: List of transitions between substates</span>
<span class="sd">    :type transitions: List[Transition]</span>
<span class="sd">    :param on_enters: List of actions to execute when entering the state</span>
<span class="sd">    :type on_enters: List[OnStage]</span>
<span class="sd">    :param on_durings: List of actions to execute while in the state</span>
<span class="sd">    :type on_durings: List[OnStage]</span>
<span class="sd">    :param on_exits: List of actions to execute when exiting the state</span>
<span class="sd">    :type on_exits: List[OnStage]</span>
<span class="sd">    :param on_during_aspects: List of aspect-oriented actions for the during stage</span>
<span class="sd">    :type on_during_aspects: List[OnAspect]</span>
<span class="sd">    :param parent_ref: Weak reference to the parent state</span>
<span class="sd">    :type parent_ref: Optional[weakref.ReferenceType]</span>
<span class="sd">    :param substate_name_to_id: Dictionary mapping substate names to numeric IDs</span>
<span class="sd">    :type substate_name_to_id: Dict[str, int]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">path</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="n">substates</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;State&#39;</span><span class="p">]</span>
    <span class="n">events</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Event</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">transitions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Transition</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">on_enters</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">OnStage</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">on_durings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">OnStage</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">on_exits</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">OnStage</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">on_during_aspects</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">OnAspect</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">parent_ref</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">weakref</span><span class="o">.</span><span class="n">ReferenceType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">substate_name_to_id</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the substate_name_to_id dictionary after instance creation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_enters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_enters</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_durings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_durings</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_exits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_exits</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_during_aspects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_during_aspects</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">substate_name_to_id</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">substates</span><span class="o">.</span><span class="n">items</span><span class="p">())}</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_leaf_state</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if this state is a leaf state (has no substates).</span>

<span class="sd">        :return: True if this is a leaf state, False otherwise</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">substates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;State&#39;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the parent state of this state.</span>

<span class="sd">        :return: The parent state or None if this is the root state</span>
<span class="sd">        :rtype: Optional[&#39;State&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_ref</span><span class="p">()</span>

    <span class="nd">@parent</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;State&#39;</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the parent state of this state.</span>

<span class="sd">        :param new_parent: The new parent state or None to clear the parent</span>
<span class="sd">        :type new_parent: Optional[&#39;State&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent_ref</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent_ref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">new_parent</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_root_state</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if this state is the root state (has no parent).</span>

<span class="sd">        :return: True if this is the root state, False otherwise</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transitions_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Transition</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all transitions that start from this state.</span>

<span class="sd">        For non-root states, these are transitions in the parent state where this state</span>
<span class="sd">        is the source. For the root state, a synthetic transition to EXIT_STATE is returned.</span>

<span class="sd">        :return: List of transitions from this state</span>
<span class="sd">        :rtype: List[Transition]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">transition</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">transitions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">transition</span><span class="o">.</span><span class="n">from_state</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">transition</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Transition</span><span class="p">(</span>
                <span class="n">from_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">to_state</span><span class="o">=</span><span class="n">EXIT_STATE</span><span class="p">,</span>
                <span class="n">event</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">guard</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">effects</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">parent_ref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_ref</span><span class="p">,</span>
            <span class="p">))</span>
        <span class="k">return</span> <span class="n">retval</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transitions_to</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Transition</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all transitions that end at this state.</span>

<span class="sd">        For non-root states, these are transitions in the parent state where this state</span>
<span class="sd">        is the target. For the root state, a synthetic transition from INIT_STATE is returned.</span>

<span class="sd">        :return: List of transitions to this state</span>
<span class="sd">        :rtype: List[Transition]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">transition</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">transitions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">transition</span><span class="o">.</span><span class="n">to_state</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">transition</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Transition</span><span class="p">(</span>
                <span class="n">from_state</span><span class="o">=</span><span class="n">INIT_STATE</span><span class="p">,</span>
                <span class="n">to_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">event</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">guard</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">effects</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">parent_ref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_ref</span><span class="p">,</span>
            <span class="p">))</span>

        <span class="k">return</span> <span class="n">retval</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transitions_entering_children</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Transition</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all transitions that start from the initial state (INIT_STATE).</span>

<span class="sd">        These are the transitions that define the initial substate when entering this state.</span>

<span class="sd">        :return: List of transitions from INIT_STATE</span>
<span class="sd">        :rtype: List[Transition]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">transition</span> <span class="k">for</span> <span class="n">transition</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span>
            <span class="k">if</span> <span class="n">transition</span><span class="o">.</span><span class="n">from_state</span> <span class="ow">is</span> <span class="n">INIT_STATE</span>
        <span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transitions_entering_children_simplified</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Transition</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a simplified list of transitions entering child states.</span>

<span class="sd">        If there&#39;s a default transition (no event or guard), only include that one.</span>
<span class="sd">        Otherwise include all transitions and add None at the end.</span>

<span class="sd">        :return: List of transitions, possibly with None at the end</span>
<span class="sd">        :rtype: List[Optional[Transition]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">transition</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">transition</span><span class="o">.</span><span class="n">from_state</span> <span class="ow">is</span> <span class="n">INIT_STATE</span><span class="p">:</span>
                <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">transition</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">transition</span><span class="o">.</span><span class="n">event</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">transition</span><span class="o">.</span><span class="n">guard</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">retval</span> <span class="ow">or</span> <span class="p">(</span><span class="n">retval</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">retval</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">event</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">retval</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">guard</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">retval</span>

<div class="viewcode-block" id="State.list_on_enters">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.State.list_on_enters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">list_on_enters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_abstract</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">with_ids</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">OnStage</span><span class="p">],</span> <span class="n">OnStage</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a list of enter actions, optionally filtered by abstract status and with IDs.</span>

<span class="sd">        :param is_abstract: If provided, filter to only abstract (True) or non-abstract (False) actions</span>
<span class="sd">        :type is_abstract: Optional[bool]</span>
<span class="sd">        :param with_ids: Whether to include numeric IDs with the actions</span>
<span class="sd">        :type with_ids: bool</span>
<span class="sd">        :return: List of enter actions, optionally with IDs</span>
<span class="sd">        :rtype: List[Union[Tuple[int, OnStage], OnStage]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">id_</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_enters</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is_abstract</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                    <span class="p">((</span><span class="n">item</span><span class="o">.</span><span class="n">is_abstract</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_abstract</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">item</span><span class="o">.</span><span class="n">is_abstract</span> <span class="ow">and</span> <span class="n">is_abstract</span><span class="p">))):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">with_ids</span><span class="p">:</span>
                <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">id_</span><span class="p">,</span> <span class="n">item</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">retval</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">abstract_on_enters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">OnStage</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all abstract enter actions.</span>

<span class="sd">        :return: List of abstract enter actions</span>
<span class="sd">        :rtype: List[OnStage]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_on_enters</span><span class="p">(</span><span class="n">is_abstract</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">non_abstract_on_enters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">OnStage</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all non-abstract enter actions.</span>

<span class="sd">        :return: List of non-abstract enter actions</span>
<span class="sd">        :rtype: List[OnStage]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_on_enters</span><span class="p">(</span><span class="n">is_abstract</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">with_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="State.list_on_durings">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.State.list_on_durings">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">list_on_durings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_abstract</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">aspect</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">with_ids</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">OnStage</span><span class="p">],</span> <span class="n">OnStage</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a list of during actions, optionally filtered by abstract status, aspect, and with IDs.</span>

<span class="sd">        :param is_abstract: If provided, filter to only abstract (True) or non-abstract (False) actions</span>
<span class="sd">        :type is_abstract: Optional[bool]</span>
<span class="sd">        :param aspect: If provided, filter to only actions with the given aspect (&#39;before&#39; or &#39;after&#39;)</span>
<span class="sd">        :type aspect: Optional[str]</span>
<span class="sd">        :param with_ids: Whether to include numeric IDs with the actions</span>
<span class="sd">        :type with_ids: bool</span>
<span class="sd">        :return: List of during actions, optionally with IDs</span>
<span class="sd">        :rtype: List[Union[Tuple[int, OnStage], OnStage]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">id_</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_durings</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is_abstract</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                    <span class="p">((</span><span class="n">item</span><span class="o">.</span><span class="n">is_abstract</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_abstract</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">item</span><span class="o">.</span><span class="n">is_abstract</span> <span class="ow">and</span> <span class="n">is_abstract</span><span class="p">))):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">aspect</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">item</span><span class="o">.</span><span class="n">aspect</span> <span class="o">!=</span> <span class="n">aspect</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">with_ids</span><span class="p">:</span>
                <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">id_</span><span class="p">,</span> <span class="n">item</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">retval</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">abstract_on_durings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">OnStage</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all abstract during actions.</span>

<span class="sd">        :return: List of abstract during actions</span>
<span class="sd">        :rtype: List[OnStage]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_on_durings</span><span class="p">(</span><span class="n">is_abstract</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">non_abstract_on_durings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">OnStage</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all non-abstract during actions.</span>

<span class="sd">        :return: List of non-abstract during actions</span>
<span class="sd">        :rtype: List[OnStage]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_on_durings</span><span class="p">(</span><span class="n">is_abstract</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">with_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="State.list_on_exits">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.State.list_on_exits">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">list_on_exits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_abstract</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">with_ids</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">OnStage</span><span class="p">],</span> <span class="n">OnStage</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a list of exit actions, optionally filtered by abstract status and with IDs.</span>

<span class="sd">        :param is_abstract: If provided, filter to only abstract (True) or non-abstract (False) actions</span>
<span class="sd">        :type is_abstract: Optional[bool]</span>
<span class="sd">        :param with_ids: Whether to include numeric IDs with the actions</span>
<span class="sd">        :type with_ids: bool</span>
<span class="sd">        :return: List of exit actions, optionally with IDs</span>
<span class="sd">        :rtype: List[Union[Tuple[int, OnStage], OnStage]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">id_</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_exits</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is_abstract</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                    <span class="p">((</span><span class="n">item</span><span class="o">.</span><span class="n">is_abstract</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_abstract</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">item</span><span class="o">.</span><span class="n">is_abstract</span> <span class="ow">and</span> <span class="n">is_abstract</span><span class="p">))):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">with_ids</span><span class="p">:</span>
                <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">id_</span><span class="p">,</span> <span class="n">item</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">retval</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">abstract_on_exits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">OnStage</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all abstract exit actions.</span>

<span class="sd">        :return: List of abstract exit actions</span>
<span class="sd">        :rtype: List[OnStage]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_on_exits</span><span class="p">(</span><span class="n">is_abstract</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">non_abstract_on_exits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">OnStage</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all non-abstract exit actions.</span>

<span class="sd">        :return: List of non-abstract exit actions</span>
<span class="sd">        :rtype: List[OnStage]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_on_exits</span><span class="p">(</span><span class="n">is_abstract</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">with_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="State.list_on_during_aspects">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.State.list_on_during_aspects">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">list_on_during_aspects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_abstract</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">aspect</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">with_ids</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">OnAspect</span><span class="p">],</span> <span class="n">OnAspect</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a list of during aspect actions, optionally filtered by abstract status, aspect, and with IDs.</span>

<span class="sd">        :param is_abstract: If provided, filter to only abstract (True) or non-abstract (False) actions</span>
<span class="sd">        :type is_abstract: Optional[bool]</span>
<span class="sd">        :param aspect: If provided, filter to only actions with the given aspect (&#39;before&#39; or &#39;after&#39;)</span>
<span class="sd">        :type aspect: Optional[str]</span>
<span class="sd">        :param with_ids: Whether to include numeric IDs with the actions</span>
<span class="sd">        :type with_ids: bool</span>
<span class="sd">        :return: List of during aspect actions, optionally with IDs</span>
<span class="sd">        :rtype: List[Union[Tuple[int, OnAspect], OnAspect]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">id_</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_during_aspects</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is_abstract</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                    <span class="p">((</span><span class="n">item</span><span class="o">.</span><span class="n">is_abstract</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_abstract</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">item</span><span class="o">.</span><span class="n">is_abstract</span> <span class="ow">and</span> <span class="n">is_abstract</span><span class="p">))):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">aspect</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">item</span><span class="o">.</span><span class="n">aspect</span> <span class="o">!=</span> <span class="n">aspect</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">with_ids</span><span class="p">:</span>
                <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">id_</span><span class="p">,</span> <span class="n">item</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">retval</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">abstract_on_during_aspects</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">OnAspect</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all abstract during aspect actions.</span>

<span class="sd">        :return: List of abstract during aspect actions</span>
<span class="sd">        :rtype: List[OnAspect]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_on_during_aspects</span><span class="p">(</span><span class="n">is_abstract</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">non_abstract_on_during_aspects</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">OnAspect</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all non-abstract during aspect actions.</span>

<span class="sd">        :return: List of non-abstract during aspect actions</span>
<span class="sd">        :rtype: List[OnAspect]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_on_during_aspects</span><span class="p">(</span><span class="n">is_abstract</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">with_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="State.iter_on_during_before_aspect_recursively">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.State.iter_on_during_before_aspect_recursively">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter_on_during_before_aspect_recursively</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_abstract</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">with_ids</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;State&#39;</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">OnAspect</span><span class="p">,</span> <span class="n">OnStage</span><span class="p">]],</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;State&#39;</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">OnAspect</span><span class="p">,</span> <span class="n">OnStage</span><span class="p">]]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively iterate through &#39;before&#39; aspect during actions from parent states to this state.</span>

<span class="sd">        This method traverses the state hierarchy from the root state to this state,</span>
<span class="sd">        yielding all &#39;before&#39; aspect during actions along the way.</span>

<span class="sd">        :param is_abstract: If provided, filter to only abstract (True) or non-abstract (False) actions</span>
<span class="sd">        :type is_abstract: Optional[bool]</span>
<span class="sd">        :param with_ids: Whether to include numeric IDs with the actions</span>
<span class="sd">        :type with_ids: bool</span>
<span class="sd">        :yield: Tuples of (state, action) or (id, state, action) if with_ids is True</span>
<span class="sd">        :rtype: List[Union[Tuple[int, &#39;State&#39;, Union[OnAspect, OnStage]], Tuple[&#39;State&#39;, Union[OnAspect, OnStage]]]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">iter_on_during_before_aspect_recursively</span><span class="p">(</span><span class="n">is_abstract</span><span class="o">=</span><span class="n">is_abstract</span><span class="p">,</span> <span class="n">with_ids</span><span class="o">=</span><span class="n">with_ids</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">with_ids</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">id_</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_on_during_aspects</span><span class="p">(</span><span class="n">is_abstract</span><span class="o">=</span><span class="n">is_abstract</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;before&#39;</span><span class="p">,</span> <span class="n">with_ids</span><span class="o">=</span><span class="n">with_ids</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">id_</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">item</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_on_during_aspects</span><span class="p">(</span><span class="n">is_abstract</span><span class="o">=</span><span class="n">is_abstract</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;before&#39;</span><span class="p">,</span> <span class="n">with_ids</span><span class="o">=</span><span class="n">with_ids</span><span class="p">):</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="p">,</span> <span class="n">item</span></div>


<div class="viewcode-block" id="State.iter_on_during_after_aspect_recursively">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.State.iter_on_during_after_aspect_recursively">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter_on_during_after_aspect_recursively</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_abstract</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">with_ids</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;State&#39;</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">OnAspect</span><span class="p">,</span> <span class="n">OnStage</span><span class="p">]],</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;State&#39;</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">OnAspect</span><span class="p">,</span> <span class="n">OnStage</span><span class="p">]]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively iterate through &#39;after&#39; aspect during actions from this state to the root state.</span>

<span class="sd">        This method traverses the state hierarchy from this state to the root state,</span>
<span class="sd">        yielding all &#39;after&#39; aspect during actions along the way.</span>

<span class="sd">        :param is_abstract: If provided, filter to only abstract (True) or non-abstract (False) actions</span>
<span class="sd">        :type is_abstract: Optional[bool]</span>
<span class="sd">        :param with_ids: Whether to include numeric IDs with the actions</span>
<span class="sd">        :type with_ids: bool</span>
<span class="sd">        :yield: Tuples of (state, action) or (id, state, action) if with_ids is True</span>
<span class="sd">        :rtype: List[Union[Tuple[int, &#39;State&#39;, Union[OnAspect, OnStage]], Tuple[&#39;State&#39;, Union[OnAspect, OnStage]]]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">with_ids</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">id_</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_on_during_aspects</span><span class="p">(</span><span class="n">is_abstract</span><span class="o">=</span><span class="n">is_abstract</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;after&#39;</span><span class="p">,</span> <span class="n">with_ids</span><span class="o">=</span><span class="n">with_ids</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">id_</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">item</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_on_during_aspects</span><span class="p">(</span><span class="n">is_abstract</span><span class="o">=</span><span class="n">is_abstract</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;after&#39;</span><span class="p">,</span> <span class="n">with_ids</span><span class="o">=</span><span class="n">with_ids</span><span class="p">):</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="p">,</span> <span class="n">item</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">iter_on_during_after_aspect_recursively</span><span class="p">(</span><span class="n">is_abstract</span><span class="o">=</span><span class="n">is_abstract</span><span class="p">,</span> <span class="n">with_ids</span><span class="o">=</span><span class="n">with_ids</span><span class="p">)</span></div>


<div class="viewcode-block" id="State.iter_on_during_aspect_recursively">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.State.iter_on_during_aspect_recursively">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter_on_during_aspect_recursively</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_abstract</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">with_ids</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;State&#39;</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">OnAspect</span><span class="p">,</span> <span class="n">OnStage</span><span class="p">]],</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;State&#39;</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">OnAspect</span><span class="p">,</span> <span class="n">OnStage</span><span class="p">]]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively iterate through all during actions in the proper execution order.</span>

<span class="sd">        This method yields actions in the following order:</span>

<span class="sd">        1. &#39;Before&#39; aspect actions from root state to this state</span>
<span class="sd">        2. Regular during actions for this state</span>
<span class="sd">        3. &#39;After&#39; aspect actions from this state to root state</span>

<span class="sd">        :param is_abstract: If provided, filter to only abstract (True) or non-abstract (False) actions</span>
<span class="sd">        :type is_abstract: Optional[bool]</span>
<span class="sd">        :param with_ids: Whether to include numeric IDs with the actions</span>
<span class="sd">        :type with_ids: bool</span>
<span class="sd">        :yield: Tuples of (state, action) or (id, state, action) if with_ids is True</span>
<span class="sd">        :rtype: List[Union[Tuple[int, &#39;State&#39;, Union[OnAspect, OnStage]], Tuple[&#39;State&#39;, Union[OnAspect, OnStage]]]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_on_during_before_aspect_recursively</span><span class="p">(</span><span class="n">is_abstract</span><span class="o">=</span><span class="n">is_abstract</span><span class="p">,</span> <span class="n">with_ids</span><span class="o">=</span><span class="n">with_ids</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">with_ids</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">id_</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_on_durings</span><span class="p">(</span><span class="n">is_abstract</span><span class="o">=</span><span class="n">is_abstract</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">with_ids</span><span class="o">=</span><span class="n">with_ids</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">id_</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">item</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_on_durings</span><span class="p">(</span><span class="n">is_abstract</span><span class="o">=</span><span class="n">is_abstract</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">with_ids</span><span class="o">=</span><span class="n">with_ids</span><span class="p">):</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="p">,</span> <span class="n">item</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_on_during_after_aspect_recursively</span><span class="p">(</span><span class="n">is_abstract</span><span class="o">=</span><span class="n">is_abstract</span><span class="p">,</span> <span class="n">with_ids</span><span class="o">=</span><span class="n">with_ids</span><span class="p">)</span></div>


<div class="viewcode-block" id="State.list_on_during_aspect_recursively">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.State.list_on_during_aspect_recursively">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">list_on_during_aspect_recursively</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_abstract</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">with_ids</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;State&#39;</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">OnAspect</span><span class="p">,</span> <span class="n">OnStage</span><span class="p">]],</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;State&#39;</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">OnAspect</span><span class="p">,</span> <span class="n">OnStage</span><span class="p">]]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a list of all during actions in the proper execution order.</span>

<span class="sd">        This is a convenience method that collects the results of iter_on_during_aspect_recursively.</span>

<span class="sd">        :param is_abstract: If provided, filter to only abstract (True) or non-abstract (False) actions</span>
<span class="sd">        :type is_abstract: Optional[bool]</span>
<span class="sd">        :param with_ids: Whether to include numeric IDs with the actions</span>
<span class="sd">        :type with_ids: bool</span>
<span class="sd">        :return: List of during actions in execution order</span>
<span class="sd">        :rtype: List[Union[Tuple[int, &#39;State&#39;, Union[OnAspect, OnStage]], Tuple[&#39;State&#39;, Union[OnAspect, OnStage]]]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_on_during_aspect_recursively</span><span class="p">(</span><span class="n">is_abstract</span><span class="p">,</span> <span class="n">with_ids</span><span class="p">))</span></div>


<div class="viewcode-block" id="State.transition_to_ast_node">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.State.transition_to_ast_node">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transition_to_ast_node</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;State&#39;</span><span class="p">],</span> <span class="n">transition</span><span class="p">:</span> <span class="n">Transition</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a transition to an AST node, considering the context of its parent state.</span>

<span class="sd">        :param self: The parent state, or None</span>
<span class="sd">        :type self: Optional[&#39;State&#39;]</span>
<span class="sd">        :param transition: The transition to convert</span>
<span class="sd">        :type transition: Transition</span>
<span class="sd">        :return: A transition definition AST node</span>
<span class="sd">        :rtype: dsl_nodes.TransitionDefinition</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">cur_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cur_path</span> <span class="o">=</span> <span class="p">()</span>

        <span class="k">if</span> <span class="n">transition</span><span class="o">.</span><span class="n">event</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">transition</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cur_path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">transition</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">path</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">cur_path</span><span class="p">)]</span> <span class="o">==</span> <span class="n">cur_path</span><span class="p">:</span>
                <span class="c1"># is relative path</span>
                <span class="n">event_id</span> <span class="o">=</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">ChainID</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">transition</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">cur_path</span><span class="p">):]),</span> <span class="n">is_absolute</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># use absolute path</span>
                <span class="n">event_id</span> <span class="o">=</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">ChainID</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">transition</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="n">is_absolute</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">event_id</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">TransitionDefinition</span><span class="p">(</span>
            <span class="n">from_state</span><span class="o">=</span><span class="n">transition</span><span class="o">.</span><span class="n">from_state</span><span class="p">,</span>
            <span class="n">to_state</span><span class="o">=</span><span class="n">transition</span><span class="o">.</span><span class="n">to_state</span><span class="p">,</span>
            <span class="n">event_id</span><span class="o">=</span><span class="n">event_id</span><span class="p">,</span>
            <span class="n">condition_expr</span><span class="o">=</span><span class="n">transition</span><span class="o">.</span><span class="n">guard</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">()</span> <span class="k">if</span> <span class="n">transition</span><span class="o">.</span><span class="n">guard</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">post_operations</span><span class="o">=</span><span class="p">[</span>
                <span class="n">item</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">transition</span><span class="o">.</span><span class="n">effects</span>
            <span class="p">]</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="State.to_transition_ast_node">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.State.to_transition_ast_node">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_transition_ast_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transition</span><span class="p">:</span> <span class="n">Transition</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">TransitionDefinition</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a transition to an AST node in the context of this state.</span>

<span class="sd">        :param transition: The transition to convert</span>
<span class="sd">        :type transition: Transition</span>
<span class="sd">        :return: A transition definition AST node</span>
<span class="sd">        :rtype: dsl_nodes.TransitionDefinition</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_to_ast_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transition</span><span class="p">)</span></div>


<div class="viewcode-block" id="State.to_ast_node">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.State.to_ast_node">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_ast_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">StateDefinition</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert this state to an AST node.</span>

<span class="sd">        :return: A state definition AST node</span>
<span class="sd">        :rtype: dsl_nodes.StateDefinition</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">StateDefinition</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">substates</span><span class="o">=</span><span class="p">[</span>
                <span class="n">substate</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">substate</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">substates</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">],</span>
            <span class="n">transitions</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">to_transition_ast_node</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="k">for</span> <span class="n">trans</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">],</span>
            <span class="n">enters</span><span class="o">=</span><span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_enters</span><span class="p">],</span>
            <span class="n">durings</span><span class="o">=</span><span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_durings</span><span class="p">],</span>
            <span class="n">exits</span><span class="o">=</span><span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_exits</span><span class="p">],</span>
            <span class="n">during_aspects</span><span class="o">=</span><span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_during_aspects</span><span class="p">],</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="State.to_plantuml">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.State.to_plantuml">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_plantuml</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert this state to PlantUML notation.</span>

<span class="sd">        :return: PlantUML representation of the state</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span> <span class="k">as</span> <span class="n">sf</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf_state</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;state </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;state </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> </span><span class="se">{{</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sf</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">substates</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">to_plantuml</span><span class="p">(),</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;    &#39;</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="n">sf</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">trans</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">:</span>
                    <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span> <span class="k">as</span> <span class="n">tf</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[*]&#39;</span> <span class="k">if</span> <span class="n">trans</span><span class="o">.</span><span class="n">from_state</span> <span class="ow">is</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">INIT_STATE</span> <span class="k">else</span> <span class="n">trans</span><span class="o">.</span><span class="n">from_state</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">tf</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; --&gt; &#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">tf</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[*]&#39;</span> <span class="k">if</span> <span class="n">trans</span><span class="o">.</span><span class="n">to_state</span> <span class="ow">is</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">EXIT_STATE</span> <span class="k">else</span> <span class="n">trans</span><span class="o">.</span><span class="n">to_state</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">tf</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">trans</span><span class="o">.</span><span class="n">event</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; : </span><span class="si">{</span><span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">trans</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">):]))</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">tf</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">trans</span><span class="o">.</span><span class="n">guard</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; : </span><span class="si">{</span><span class="n">trans</span><span class="o">.</span><span class="n">guard</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">tf</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trans</span><span class="o">.</span><span class="n">effects</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">tf</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;note on link&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">tf</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;effect {&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">tf</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">operation</span> <span class="ow">in</span> <span class="n">trans</span><span class="o">.</span><span class="n">effects</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    </span><span class="si">{</span><span class="n">operation</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">tf</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;}&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">tf</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;end note&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">tf</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

                        <span class="n">trans_text</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="n">trans_text</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;    &#39;</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="n">sf</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">}}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_enters</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_durings</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_exits</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sf</span><span class="p">)</span>
                <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span> <span class="k">as</span> <span class="n">tf</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">enter_item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_enters</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">enter_item</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">(),</span> <span class="n">file</span><span class="o">=</span><span class="n">tf</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">during_item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_durings</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">during_item</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">(),</span> <span class="n">file</span><span class="o">=</span><span class="n">tf</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">exit_item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_exits</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">exit_item</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">(),</span> <span class="n">file</span><span class="o">=</span><span class="n">tf</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">during_aspect_item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_during_aspects</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">during_aspect_item</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">(),</span> <span class="n">file</span><span class="o">=</span><span class="n">tf</span><span class="p">)</span>
                    <span class="n">text</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> : </span><span class="si">{</span><span class="n">text</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">sf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span></div>


<div class="viewcode-block" id="State.walk_states">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.State.walk_states">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">walk_states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate through this state and all its substates recursively.</span>

<span class="sd">        :yield: Each state in the hierarchy, starting with this one</span>
<span class="sd">        :rtype: Iterator[&#39;State&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">substate</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">substates</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">yield from</span> <span class="n">substate</span><span class="o">.</span><span class="n">walk_states</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="VarDefine">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.VarDefine">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">VarDefine</span><span class="p">(</span><span class="n">AstExportable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a variable definition in a state machine.</span>

<span class="sd">    :param name: The name of the variable</span>
<span class="sd">    :type name: str</span>
<span class="sd">    :param type: The type of the variable</span>
<span class="sd">    :type type: str</span>
<span class="sd">    :param init: The initial value expression</span>
<span class="sd">    :type init: Expr</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">init</span><span class="p">:</span> <span class="n">Expr</span>

<div class="viewcode-block" id="VarDefine.to_ast_node">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.VarDefine.to_ast_node">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_ast_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">DefAssignment</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert this variable definition to an AST node.</span>

<span class="sd">        :return: A definition assignment AST node</span>
<span class="sd">        :rtype: dsl_nodes.DefAssignment</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">DefAssignment</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
            <span class="n">expr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">(),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="VarDefine.name_ast_node">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.VarDefine.name_ast_node">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">name_ast_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">Name</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the variable name to an AST node.</span>

<span class="sd">        :return: A name AST node</span>
<span class="sd">        :rtype: dsl_nodes.Name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">Name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="StateMachine">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.StateMachine">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">StateMachine</span><span class="p">(</span><span class="n">AstExportable</span><span class="p">,</span> <span class="n">PlantUMLExportable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a complete state machine with variable definitions and a root state.</span>

<span class="sd">    :param defines: Dictionary mapping variable names to their definitions</span>
<span class="sd">    :type defines: Dict[str, VarDefine]</span>
<span class="sd">    :param root_state: The root state of the state machine</span>
<span class="sd">    :type root_state: State</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">defines</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">VarDefine</span><span class="p">]</span>
    <span class="n">root_state</span><span class="p">:</span> <span class="n">State</span>

<div class="viewcode-block" id="StateMachine.to_ast_node">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.StateMachine.to_ast_node">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_ast_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">StateMachineDSLProgram</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert this state machine to an AST node.</span>

<span class="sd">        :return: A state machine DSL program AST node</span>
<span class="sd">        :rtype: dsl_nodes.StateMachineDSLProgram</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">StateMachineDSLProgram</span><span class="p">(</span>
            <span class="n">definitions</span><span class="o">=</span><span class="p">[</span>
                <span class="n">def_item</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">def_item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">],</span>
            <span class="n">root_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">root_state</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">(),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="StateMachine.to_plantuml">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.StateMachine.to_plantuml">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_plantuml</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert this state machine to PlantUML notation.</span>

<span class="sd">        :return: PlantUML representation of the state machine</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span> <span class="k">as</span> <span class="n">sf</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;@startuml&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sf</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;note as DefinitionNote&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sf</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;defines {&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sf</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">def_item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    </span><span class="si">{</span><span class="n">def_item</span><span class="o">.</span><span class="n">to_ast_node</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sf</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;}&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sf</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;end note&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sf</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sf</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_state</span><span class="o">.</span><span class="n">to_plantuml</span><span class="p">(),</span> <span class="n">file</span><span class="o">=</span><span class="n">sf</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[*] --&gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">root_state</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sf</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">root_state</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> --&gt; [*]&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sf</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;@enduml&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">sf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span></div>


<div class="viewcode-block" id="StateMachine.walk_states">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.StateMachine.walk_states">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">walk_states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate through all states in the state machine.</span>

<span class="sd">        :yield: Each state in the hierarchy</span>
<span class="sd">        :rtype: Iterator[State]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_state</span><span class="o">.</span><span class="n">walk_states</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="parse_dsl_node_to_state_machine">
<a class="viewcode-back" href="../../../api_doc/model/model.html#pyfcstm.model.model.parse_dsl_node_to_state_machine">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parse_dsl_node_to_state_machine</span><span class="p">(</span><span class="n">dnode</span><span class="p">:</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">StateMachineDSLProgram</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StateMachine</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse a state machine DSL program AST node into a StateMachine object.</span>

<span class="sd">    This function validates the state machine structure and builds a complete</span>
<span class="sd">    StateMachine object with all states, transitions, events, and variable definitions.</span>

<span class="sd">    :param dnode: The state machine DSL program AST node to parse</span>
<span class="sd">    :type dnode: dsl_nodes.StateMachineDSLProgram</span>

<span class="sd">    :return: The parsed state machine</span>
<span class="sd">    :rtype: StateMachine</span>

<span class="sd">    :raises SyntaxError: If there are syntax errors in the state machine definition,</span>
<span class="sd">                         such as duplicate variable definitions, unknown states in</span>
<span class="sd">                         transitions, missing entry transitions, etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d_defines</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">def_item</span> <span class="ow">in</span> <span class="n">dnode</span><span class="o">.</span><span class="n">definitions</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">def_item</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_defines</span><span class="p">:</span>
            <span class="n">d_defines</span><span class="p">[</span><span class="n">def_item</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">VarDefine</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">def_item</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="nb">type</span><span class="o">=</span><span class="n">def_item</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                <span class="n">init</span><span class="o">=</span><span class="n">parse_expr_node_to_expr</span><span class="p">(</span><span class="n">def_item</span><span class="o">.</span><span class="n">expr</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Duplicated variable definition - </span><span class="si">{</span><span class="n">def_item</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_recursive_build_states</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">StateDefinition</span><span class="p">,</span> <span class="n">current_path</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]):</span>
        <span class="n">current_path</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="o">*</span><span class="n">current_path</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="n">d_substates</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">subnode</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">substates</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">subnode</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_substates</span><span class="p">:</span>
                <span class="n">d_substates</span><span class="p">[</span><span class="n">subnode</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_recursive_build_states</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">current_path</span><span class="o">=</span><span class="n">current_path</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Duplicate state name in namespace </span><span class="si">{</span><span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">current_path</span><span class="p">)</span><span class="si">!r}</span><span class="s1">:</span><span class="se">\n</span><span class="si">{</span><span class="n">subnode</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">my_state</span> <span class="o">=</span> <span class="n">State</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">path</span><span class="o">=</span><span class="n">current_path</span><span class="p">,</span>
            <span class="n">substates</span><span class="o">=</span><span class="n">d_substates</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">substate</span> <span class="ow">in</span> <span class="n">d_substates</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">substate</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">my_state</span>
        <span class="k">return</span> <span class="n">my_state</span>

    <span class="n">root_state</span> <span class="o">=</span> <span class="n">_recursive_build_states</span><span class="p">(</span><span class="n">dnode</span><span class="o">.</span><span class="n">root_state</span><span class="p">,</span> <span class="n">current_path</span><span class="o">=</span><span class="p">())</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_recursive_finish_states</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">StateDefinition</span><span class="p">,</span> <span class="n">current_state</span><span class="p">:</span> <span class="n">State</span><span class="p">,</span> <span class="n">current_path</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                                 <span class="n">force_transitions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">dsl_nodes</span><span class="o">.</span><span class="n">ForceTransitionDefinition</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">current_path</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="o">*</span><span class="n">current_path</span><span class="p">,</span> <span class="n">current_state</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="n">force_transitions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">force_transitions</span> <span class="ow">or</span> <span class="p">[])</span>

        <span class="n">force_transition_tuples_to_inherit</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f_transnode</span> <span class="ow">in</span> <span class="p">[</span><span class="o">*</span><span class="n">force_transitions</span><span class="p">,</span> <span class="o">*</span><span class="n">node</span><span class="o">.</span><span class="n">force_transitions</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">f_transnode</span><span class="o">.</span><span class="n">from_state</span> <span class="o">==</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">ALL</span><span class="p">:</span>
                <span class="n">from_state</span> <span class="o">=</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">ALL</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">from_state</span> <span class="o">=</span> <span class="n">f_transnode</span><span class="o">.</span><span class="n">from_state</span>
                <span class="k">if</span> <span class="n">from_state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">current_state</span><span class="o">.</span><span class="n">substates</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown from state </span><span class="si">{</span><span class="n">from_state</span><span class="si">!r}</span><span class="s1"> of force transition:</span><span class="se">\n</span><span class="si">{</span><span class="n">f_transnode</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">f_transnode</span><span class="o">.</span><span class="n">to_state</span> <span class="ow">is</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">EXIT_STATE</span><span class="p">:</span>
                <span class="n">to_state</span> <span class="o">=</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">EXIT_STATE</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">to_state</span> <span class="o">=</span> <span class="n">f_transnode</span><span class="o">.</span><span class="n">to_state</span>
                <span class="k">if</span> <span class="n">to_state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">current_state</span><span class="o">.</span><span class="n">substates</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown to state </span><span class="si">{</span><span class="n">to_state</span><span class="si">!r}</span><span class="s1"> of force transition:</span><span class="se">\n</span><span class="si">{</span><span class="n">f_transnode</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="n">my_event_id</span><span class="p">,</span> <span class="n">trans_event</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">f_transnode</span><span class="o">.</span><span class="n">event_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">my_event_id</span> <span class="o">=</span> <span class="n">f_transnode</span><span class="o">.</span><span class="n">event_id</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">my_event_id</span><span class="o">.</span><span class="n">is_absolute</span><span class="p">:</span>
                    <span class="n">my_event_id</span> <span class="o">=</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">ChainID</span><span class="p">(</span>
                        <span class="n">path</span><span class="o">=</span><span class="p">[</span><span class="o">*</span><span class="n">current_state</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="o">*</span><span class="n">my_event_id</span><span class="o">.</span><span class="n">path</span><span class="p">],</span>
                        <span class="n">is_absolute</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>
                <span class="n">start_state</span> <span class="o">=</span> <span class="n">root_state</span>
                <span class="n">base_path</span> <span class="o">=</span> <span class="p">(</span><span class="n">root_state</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>
                <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">my_event_id</span><span class="o">.</span><span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">start_state</span><span class="o">.</span><span class="n">substates</span><span class="p">:</span>
                        <span class="n">start_state</span> <span class="o">=</span> <span class="n">start_state</span><span class="o">.</span><span class="n">substates</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s1">&#39;Cannot find state </span><span class="si">{</span><span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="o">*</span><span class="n">base_path</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">my_event_id</span><span class="o">.</span><span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="si">}</span><span class="s1"> for transition:</span><span class="se">\n</span><span class="si">{</span><span class="n">f_transnode</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="n">suffix_name</span> <span class="o">=</span> <span class="n">my_event_id</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">suffix_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">start_state</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
                    <span class="n">start_state</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">suffix_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Event</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">suffix_name</span><span class="p">,</span>
                        <span class="n">state_path</span><span class="o">=</span><span class="n">start_state</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="n">trans_event</span> <span class="o">=</span> <span class="n">start_state</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">suffix_name</span><span class="p">]</span>

            <span class="n">condition_expr</span><span class="p">,</span> <span class="n">guard</span> <span class="o">=</span> <span class="n">f_transnode</span><span class="o">.</span><span class="n">condition_expr</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">f_transnode</span><span class="o">.</span><span class="n">condition_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">guard</span> <span class="o">=</span> <span class="n">parse_expr_node_to_expr</span><span class="p">(</span><span class="n">f_transnode</span><span class="o">.</span><span class="n">condition_expr</span><span class="p">)</span>
                <span class="n">unknown_vars</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">guard</span><span class="o">.</span><span class="n">list_variables</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_defines</span><span class="p">:</span>
                        <span class="n">unknown_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">unknown_vars</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;Unknown guard variable </span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">unknown_vars</span><span class="p">)</span><span class="si">}</span><span class="s1"> in force transition:</span><span class="se">\n</span><span class="si">{</span><span class="n">f_transnode</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="n">force_transition_tuples_to_inherit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span><span class="n">from_state</span><span class="p">,</span> <span class="n">to_state</span><span class="p">,</span> <span class="n">my_event_id</span><span class="p">,</span> <span class="n">trans_event</span><span class="p">,</span> <span class="n">condition_expr</span><span class="p">,</span> <span class="n">guard</span><span class="p">))</span>

        <span class="n">transitions</span> <span class="o">=</span> <span class="n">current_state</span><span class="o">.</span><span class="n">transitions</span>
        <span class="k">for</span> <span class="n">subnode</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">substates</span><span class="p">:</span>
            <span class="n">_inner_force_transitions</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">force_transitions</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">from_state</span><span class="p">,</span> <span class="n">to_state</span><span class="p">,</span> <span class="n">my_event_id</span><span class="p">,</span> <span class="n">trans_event</span><span class="p">,</span> <span class="n">condition_expr</span><span class="p">,</span> <span class="n">guard</span> <span class="ow">in</span> <span class="n">force_transition_tuples_to_inherit</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">from_state</span> <span class="ow">is</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">ALL</span> <span class="ow">or</span> <span class="n">from_state</span> <span class="o">==</span> <span class="n">subnode</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="n">transitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Transition</span><span class="p">(</span>
                        <span class="n">from_state</span><span class="o">=</span><span class="n">subnode</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                        <span class="n">to_state</span><span class="o">=</span><span class="n">to_state</span><span class="p">,</span>
                        <span class="n">event</span><span class="o">=</span><span class="n">trans_event</span><span class="p">,</span>
                        <span class="n">guard</span><span class="o">=</span><span class="n">guard</span><span class="p">,</span>
                        <span class="n">effects</span><span class="o">=</span><span class="p">[],</span>
                    <span class="p">))</span>
                    <span class="n">_inner_force_transitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dsl_nodes</span><span class="o">.</span><span class="n">ForceTransitionDefinition</span><span class="p">(</span>
                        <span class="n">from_state</span><span class="o">=</span><span class="n">dsl_nodes</span><span class="o">.</span><span class="n">ALL</span><span class="p">,</span>
                        <span class="n">to_state</span><span class="o">=</span><span class="n">dsl_nodes</span><span class="o">.</span><span class="n">EXIT_STATE</span><span class="p">,</span>
                        <span class="n">event_id</span><span class="o">=</span><span class="n">my_event_id</span><span class="p">,</span>
                        <span class="n">condition_expr</span><span class="o">=</span><span class="n">condition_expr</span><span class="p">,</span>
                    <span class="p">))</span>

            <span class="n">_recursive_finish_states</span><span class="p">(</span>
                <span class="n">node</span><span class="o">=</span><span class="n">subnode</span><span class="p">,</span>
                <span class="n">current_state</span><span class="o">=</span><span class="n">current_state</span><span class="o">.</span><span class="n">substates</span><span class="p">[</span><span class="n">subnode</span><span class="o">.</span><span class="n">name</span><span class="p">],</span>
                <span class="n">current_path</span><span class="o">=</span><span class="n">current_path</span><span class="p">,</span>
                <span class="n">force_transitions</span><span class="o">=</span><span class="n">_inner_force_transitions</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">has_entry_trans</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">transnode</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">transitions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">transnode</span><span class="o">.</span><span class="n">from_state</span> <span class="ow">is</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">INIT_STATE</span><span class="p">:</span>
                <span class="n">from_state</span> <span class="o">=</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">INIT_STATE</span>
                <span class="n">has_entry_trans</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">from_state</span> <span class="o">=</span> <span class="n">transnode</span><span class="o">.</span><span class="n">from_state</span>
                <span class="k">if</span> <span class="n">from_state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">current_state</span><span class="o">.</span><span class="n">substates</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown from state </span><span class="si">{</span><span class="n">from_state</span><span class="si">!r}</span><span class="s1"> of transition:</span><span class="se">\n</span><span class="si">{</span><span class="n">transnode</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">transnode</span><span class="o">.</span><span class="n">to_state</span> <span class="ow">is</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">EXIT_STATE</span><span class="p">:</span>
                <span class="n">to_state</span> <span class="o">=</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">EXIT_STATE</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">to_state</span> <span class="o">=</span> <span class="n">transnode</span><span class="o">.</span><span class="n">to_state</span>
                <span class="k">if</span> <span class="n">to_state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">current_state</span><span class="o">.</span><span class="n">substates</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown to state </span><span class="si">{</span><span class="n">to_state</span><span class="si">!r}</span><span class="s1"> of transition:</span><span class="se">\n</span><span class="si">{</span><span class="n">transnode</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="n">trans_event</span><span class="p">,</span> <span class="n">guard</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">transnode</span><span class="o">.</span><span class="n">event_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">transnode</span><span class="o">.</span><span class="n">event_id</span><span class="o">.</span><span class="n">is_absolute</span><span class="p">:</span>
                    <span class="n">start_state</span> <span class="o">=</span> <span class="n">root_state</span>
                    <span class="n">base_path</span> <span class="o">=</span> <span class="p">(</span><span class="n">root_state</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">start_state</span> <span class="o">=</span> <span class="n">current_state</span>
                    <span class="n">base_path</span> <span class="o">=</span> <span class="n">current_state</span><span class="o">.</span><span class="n">path</span>
                <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">transnode</span><span class="o">.</span><span class="n">event_id</span><span class="o">.</span><span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">start_state</span><span class="o">.</span><span class="n">substates</span><span class="p">:</span>
                        <span class="n">start_state</span> <span class="o">=</span> <span class="n">start_state</span><span class="o">.</span><span class="n">substates</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s1">&#39;Cannot find state </span><span class="si">{</span><span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="o">*</span><span class="n">base_path</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">transnode</span><span class="o">.</span><span class="n">event_id</span><span class="o">.</span><span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="si">}</span><span class="s1"> for transition:</span><span class="se">\n</span><span class="si">{</span><span class="n">transnode</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="n">suffix_name</span> <span class="o">=</span> <span class="n">transnode</span><span class="o">.</span><span class="n">event_id</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">suffix_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">start_state</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
                    <span class="n">start_state</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">suffix_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Event</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">suffix_name</span><span class="p">,</span>
                        <span class="n">state_path</span><span class="o">=</span><span class="n">start_state</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="n">trans_event</span> <span class="o">=</span> <span class="n">start_state</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">suffix_name</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">transnode</span><span class="o">.</span><span class="n">condition_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">guard</span> <span class="o">=</span> <span class="n">parse_expr_node_to_expr</span><span class="p">(</span><span class="n">transnode</span><span class="o">.</span><span class="n">condition_expr</span><span class="p">)</span>
                <span class="n">unknown_vars</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">guard</span><span class="o">.</span><span class="n">list_variables</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_defines</span><span class="p">:</span>
                        <span class="n">unknown_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">unknown_vars</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown guard variable </span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">unknown_vars</span><span class="p">)</span><span class="si">}</span><span class="s1"> in transition:</span><span class="se">\n</span><span class="si">{</span><span class="n">transnode</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="n">post_operations</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">op_item</span> <span class="ow">in</span> <span class="n">transnode</span><span class="o">.</span><span class="n">post_operations</span><span class="p">:</span>
                <span class="n">operation_val</span> <span class="o">=</span> <span class="n">parse_expr_node_to_expr</span><span class="p">(</span><span class="n">op_item</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
                <span class="n">unknown_vars</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">operation_val</span><span class="o">.</span><span class="n">list_variables</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_defines</span><span class="p">:</span>
                        <span class="n">unknown_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">op_item</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_defines</span> <span class="ow">and</span> <span class="n">op_item</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unknown_vars</span><span class="p">:</span>
                    <span class="n">unknown_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_item</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">unknown_vars</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;Unknown transition operation variable </span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">unknown_vars</span><span class="p">)</span><span class="si">}</span><span class="s1"> in transition:</span><span class="se">\n</span><span class="si">{</span><span class="n">transnode</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">post_operations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Operation</span><span class="p">(</span><span class="n">var_name</span><span class="o">=</span><span class="n">op_item</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">operation_val</span><span class="p">))</span>

            <span class="n">transition</span> <span class="o">=</span> <span class="n">Transition</span><span class="p">(</span>
                <span class="n">from_state</span><span class="o">=</span><span class="n">from_state</span><span class="p">,</span>
                <span class="n">to_state</span><span class="o">=</span><span class="n">to_state</span><span class="p">,</span>
                <span class="n">event</span><span class="o">=</span><span class="n">trans_event</span><span class="p">,</span>
                <span class="n">guard</span><span class="o">=</span><span class="n">guard</span><span class="p">,</span>
                <span class="n">effects</span><span class="o">=</span><span class="n">post_operations</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">transitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">transition</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">current_state</span><span class="o">.</span><span class="n">substates</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_entry_trans</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;At least 1 entry transition should be assigned in non-leaf state </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s1">:</span><span class="se">\n</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">on_enters</span> <span class="o">=</span> <span class="n">current_state</span><span class="o">.</span><span class="n">on_enters</span>
        <span class="k">for</span> <span class="n">enter_item</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">enters</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">enter_item</span><span class="p">,</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">EnterOperations</span><span class="p">):</span>
                <span class="n">enter_operations</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">op_item</span> <span class="ow">in</span> <span class="n">enter_item</span><span class="o">.</span><span class="n">operations</span><span class="p">:</span>
                    <span class="n">operation_val</span> <span class="o">=</span> <span class="n">parse_expr_node_to_expr</span><span class="p">(</span><span class="n">op_item</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
                    <span class="n">unknown_vars</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">operation_val</span><span class="o">.</span><span class="n">list_variables</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_defines</span><span class="p">:</span>
                            <span class="n">unknown_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">op_item</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_defines</span> <span class="ow">and</span> <span class="n">op_item</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unknown_vars</span><span class="p">:</span>
                        <span class="n">unknown_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_item</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">unknown_vars</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s1">&#39;Unknown enter operation variable </span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">unknown_vars</span><span class="p">)</span><span class="si">}</span><span class="s1"> in transition:</span><span class="se">\n</span><span class="si">{</span><span class="n">enter_item</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">enter_operations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Operation</span><span class="p">(</span><span class="n">var_name</span><span class="o">=</span><span class="n">op_item</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">operation_val</span><span class="p">))</span>
                <span class="n">on_enters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">OnStage</span><span class="p">(</span>
                    <span class="n">stage</span><span class="o">=</span><span class="s1">&#39;enter&#39;</span><span class="p">,</span>
                    <span class="n">aspect</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">enter_item</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">operations</span><span class="o">=</span><span class="n">enter_operations</span><span class="p">,</span>
                <span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">enter_item</span><span class="p">,</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">EnterAbstractFunction</span><span class="p">):</span>
                <span class="n">on_enters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">OnStage</span><span class="p">(</span>
                    <span class="n">stage</span><span class="o">=</span><span class="s1">&#39;enter&#39;</span><span class="p">,</span>
                    <span class="n">aspect</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">enter_item</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="n">enter_item</span><span class="o">.</span><span class="n">doc</span><span class="p">,</span>
                    <span class="n">operations</span><span class="o">=</span><span class="p">[],</span>
                <span class="p">))</span>

        <span class="n">on_durings</span> <span class="o">=</span> <span class="n">current_state</span><span class="o">.</span><span class="n">on_durings</span>
        <span class="k">for</span> <span class="n">during_item</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">durings</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">current_state</span><span class="o">.</span><span class="n">substates</span> <span class="ow">and</span> <span class="n">during_item</span><span class="o">.</span><span class="n">aspect</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;For leaf state </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s1">, during cannot assign aspect </span><span class="si">{</span><span class="n">during_item</span><span class="o">.</span><span class="n">aspect</span><span class="si">!r}</span><span class="s1">:</span><span class="se">\n</span><span class="si">{</span><span class="n">during_item</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">current_state</span><span class="o">.</span><span class="n">substates</span> <span class="ow">and</span> <span class="n">during_item</span><span class="o">.</span><span class="n">aspect</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;For composite state </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s1">, during must assign aspect to either </span><span class="se">\&#39;</span><span class="s1">before</span><span class="se">\&#39;</span><span class="s1"> or </span><span class="se">\&#39;</span><span class="s1">after</span><span class="se">\&#39;</span><span class="s1">:</span><span class="se">\n</span><span class="si">{</span><span class="n">during_item</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">during_item</span><span class="p">,</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">DuringOperations</span><span class="p">):</span>
                <span class="n">during_operations</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">op_item</span> <span class="ow">in</span> <span class="n">during_item</span><span class="o">.</span><span class="n">operations</span><span class="p">:</span>
                    <span class="n">operation_val</span> <span class="o">=</span> <span class="n">parse_expr_node_to_expr</span><span class="p">(</span><span class="n">op_item</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
                    <span class="n">unknown_vars</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">operation_val</span><span class="o">.</span><span class="n">list_variables</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_defines</span><span class="p">:</span>
                            <span class="n">unknown_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">op_item</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_defines</span> <span class="ow">and</span> <span class="n">op_item</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unknown_vars</span><span class="p">:</span>
                        <span class="n">unknown_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_item</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">unknown_vars</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s1">&#39;Unknown during operation variable </span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">unknown_vars</span><span class="p">)</span><span class="si">}</span><span class="s1"> in transition:</span><span class="se">\n</span><span class="si">{</span><span class="n">during_item</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">during_operations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Operation</span><span class="p">(</span><span class="n">var_name</span><span class="o">=</span><span class="n">op_item</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">operation_val</span><span class="p">))</span>
                <span class="n">on_durings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">OnStage</span><span class="p">(</span>
                    <span class="n">stage</span><span class="o">=</span><span class="s1">&#39;during&#39;</span><span class="p">,</span>
                    <span class="n">aspect</span><span class="o">=</span><span class="n">during_item</span><span class="o">.</span><span class="n">aspect</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">during_item</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">operations</span><span class="o">=</span><span class="n">during_operations</span><span class="p">,</span>
                <span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">during_item</span><span class="p">,</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">DuringAbstractFunction</span><span class="p">):</span>
                <span class="n">on_durings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">OnStage</span><span class="p">(</span>
                    <span class="n">stage</span><span class="o">=</span><span class="s1">&#39;during&#39;</span><span class="p">,</span>
                    <span class="n">aspect</span><span class="o">=</span><span class="n">during_item</span><span class="o">.</span><span class="n">aspect</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">during_item</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="n">during_item</span><span class="o">.</span><span class="n">doc</span><span class="p">,</span>
                    <span class="n">operations</span><span class="o">=</span><span class="p">[],</span>
                <span class="p">))</span>

        <span class="n">on_exits</span> <span class="o">=</span> <span class="n">current_state</span><span class="o">.</span><span class="n">on_exits</span>
        <span class="k">for</span> <span class="n">exit_item</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">exits</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exit_item</span><span class="p">,</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">ExitOperations</span><span class="p">):</span>
                <span class="n">exit_operations</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">op_item</span> <span class="ow">in</span> <span class="n">exit_item</span><span class="o">.</span><span class="n">operations</span><span class="p">:</span>
                    <span class="n">operation_val</span> <span class="o">=</span> <span class="n">parse_expr_node_to_expr</span><span class="p">(</span><span class="n">op_item</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
                    <span class="n">unknown_vars</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">operation_val</span><span class="o">.</span><span class="n">list_variables</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_defines</span><span class="p">:</span>
                            <span class="n">unknown_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">op_item</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_defines</span> <span class="ow">and</span> <span class="n">op_item</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unknown_vars</span><span class="p">:</span>
                        <span class="n">unknown_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_item</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">unknown_vars</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s1">&#39;Unknown exit operation variable </span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">unknown_vars</span><span class="p">)</span><span class="si">}</span><span class="s1"> in transition:</span><span class="se">\n</span><span class="si">{</span><span class="n">exit_item</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">exit_operations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Operation</span><span class="p">(</span><span class="n">var_name</span><span class="o">=</span><span class="n">op_item</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">operation_val</span><span class="p">))</span>
                <span class="n">on_exits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">OnStage</span><span class="p">(</span>
                    <span class="n">stage</span><span class="o">=</span><span class="s1">&#39;exit&#39;</span><span class="p">,</span>
                    <span class="n">aspect</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">exit_item</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">operations</span><span class="o">=</span><span class="n">exit_operations</span><span class="p">,</span>
                <span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exit_item</span><span class="p">,</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">ExitAbstractFunction</span><span class="p">):</span>
                <span class="n">on_exits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">OnStage</span><span class="p">(</span>
                    <span class="n">stage</span><span class="o">=</span><span class="s1">&#39;exit&#39;</span><span class="p">,</span>
                    <span class="n">aspect</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">exit_item</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="n">exit_item</span><span class="o">.</span><span class="n">doc</span><span class="p">,</span>
                    <span class="n">operations</span><span class="o">=</span><span class="p">[],</span>
                <span class="p">))</span>

        <span class="n">on_during_aspects</span> <span class="o">=</span> <span class="n">current_state</span><span class="o">.</span><span class="n">on_during_aspects</span>
        <span class="k">for</span> <span class="n">during_aspect_item</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">during_aspects</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">during_aspect_item</span><span class="p">,</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">DuringAspectOperations</span><span class="p">):</span>
                <span class="n">during_operations</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">op_item</span> <span class="ow">in</span> <span class="n">during_aspect_item</span><span class="o">.</span><span class="n">operations</span><span class="p">:</span>
                    <span class="n">operation_val</span> <span class="o">=</span> <span class="n">parse_expr_node_to_expr</span><span class="p">(</span><span class="n">op_item</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
                    <span class="n">unknown_vars</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">operation_val</span><span class="o">.</span><span class="n">list_variables</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_defines</span><span class="p">:</span>
                            <span class="n">unknown_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">op_item</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_defines</span> <span class="ow">and</span> <span class="n">op_item</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unknown_vars</span><span class="p">:</span>
                        <span class="n">unknown_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_item</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">unknown_vars</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s1">&#39;Unknown during aspect variable </span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">unknown_vars</span><span class="p">)</span><span class="si">}</span><span class="s1"> in transition:</span><span class="se">\n</span><span class="si">{</span><span class="n">during_aspect_item</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">during_operations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Operation</span><span class="p">(</span><span class="n">var_name</span><span class="o">=</span><span class="n">op_item</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">operation_val</span><span class="p">))</span>
                <span class="n">on_during_aspects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">OnAspect</span><span class="p">(</span>
                    <span class="n">stage</span><span class="o">=</span><span class="s1">&#39;during&#39;</span><span class="p">,</span>
                    <span class="n">aspect</span><span class="o">=</span><span class="n">during_aspect_item</span><span class="o">.</span><span class="n">aspect</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">during_aspect_item</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">operations</span><span class="o">=</span><span class="n">during_operations</span><span class="p">,</span>
                <span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">during_aspect_item</span><span class="p">,</span> <span class="n">dsl_nodes</span><span class="o">.</span><span class="n">DuringAspectAbstractFunction</span><span class="p">):</span>
                <span class="n">on_during_aspects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">OnAspect</span><span class="p">(</span>
                    <span class="n">stage</span><span class="o">=</span><span class="s1">&#39;during&#39;</span><span class="p">,</span>
                    <span class="n">aspect</span><span class="o">=</span><span class="n">during_aspect_item</span><span class="o">.</span><span class="n">aspect</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">during_aspect_item</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="n">during_aspect_item</span><span class="o">.</span><span class="n">doc</span><span class="p">,</span>
                    <span class="n">operations</span><span class="o">=</span><span class="p">[],</span>
                <span class="p">))</span>

        <span class="k">for</span> <span class="n">transition</span> <span class="ow">in</span> <span class="n">current_state</span><span class="o">.</span><span class="n">transitions</span><span class="p">:</span>
            <span class="n">transition</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">current_state</span>

    <span class="n">_recursive_finish_states</span><span class="p">(</span><span class="n">dnode</span><span class="o">.</span><span class="n">root_state</span><span class="p">,</span> <span class="n">current_state</span><span class="o">=</span><span class="n">root_state</span><span class="p">,</span> <span class="n">current_path</span><span class="o">=</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">StateMachine</span><span class="p">(</span>
        <span class="n">defines</span><span class="o">=</span><span class="n">d_defines</span><span class="p">,</span>
        <span class="n">root_state</span><span class="o">=</span><span class="n">root_state</span><span class="p">,</span>
    <span class="p">)</span></div>

</pre></div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, HansBug.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  
    <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: HEAD
    <span class="fa fa-caret-down"></span>
  </span>
        <div class="rst-other-versions">
                <dl>
                    <dt>Tags</dt>
                        <dd><a href="../../../../v0.0.1/index.html">v0.0.1</a></dd>
                </dl>
                <dl>
                    <dt>Branches</dt>
                        <dd><a href="../../../../main/index.html">main</a></dd>
                        <dd><a href="model.html">HEAD</a></dd>
                        <dd><a href="../../../../old_design/index.html">old_design</a></dd>
                </dl>
        </div>
    </div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>